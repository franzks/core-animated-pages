<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link href="../../polymer/polymer.html" rel="import">
<link href="../../core-animation/web-animations.html" rel="import">
<link href="../../core-style/core-style.html" rel="import">
<link href="../../core-transition/core-transition.html" rel="import">

<!--

`core-transition-pages` represents a page transition, which may include CSS and/or
script. It will look for a `core-style` element with the same `id` to install in the
scope of the `core-animated-pages` that's using the transition.

Example:

    <core-style id="fooTransition">
        // some CSS here
    </core-style>
    <core-transition-pages id="fooTransition"></core-transition-pages>

There are three stages to a page transition:

1. `prepare`: Called to set up the incoming and outgoing pages to the "before" state,
  e.g. setting the incoming page to `opacity: 0` for `cross-fade` or find and
  measure hero elements for `hero-transition`.

2. `go`: Called to run the transition. For CSS-based transitions, this generally
  applies a CSS `transition` property.

3. `complete`: Called when the elements are finished transitioning.

See the individual transition documentation for specific details.

@element core-transition-pages
@status beta
@homepage github.io
-->
<!--
Fired when the transition completes.

@event core-transitionend
-->
<polymer-element name="core-transition-pages" extends="core-transition">
<script>

(function () {

// create some basic transition styling data.
var transitions = CoreStyle.g.transitions = CoreStyle.g.transitions || {};

transitions.easing = 'cubic-bezier(0.4, 0, 0.2, 1)';

transitions.duration = 500;
transitions.heroDelay = 50;
transitions.scaleDelay = 500;
transitions.cascadeFadeDuration = 250;

transitions.xfadeDelay = 5000;

var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;

Polymer({

  publish: {
    targetAttribute: '',
    srcEffect: null,
    dstEffect: null,
    timing: null
  },

  prepare: function(scope, options) {
    // this.boundCompleteFn = this.complete.bind(this, scope);
    // if (this.scopeClass) {
    //   scope.classList.add(this.scopeClass);
    // }
    var anims = [];
    var targets = this.findTargets(options.src);
    targets.forEach(function(t) {
      anims.push(new Animation(t, this.srcEffect, this.timing));
    }.bind(this));

    targets = this.findTargets(options.dst);
    targets.forEach(function(t) {
      anims.push(new Animation(t, this.dstEffect, this.timing));
    }.bind(this));

    if (anims.length > 1) {
      this.animation = new AnimationGroup(anims);
    } else if (anims.length === 1) {
      this.animation = anims[0];
    } else {
      this.animation = null;
    }

    return this.animation;
  },

  findTargets: function(el) {
    if (!this.targetAttribute) {
      return [];
    }
    return this.findAllInShadows(el, '[' + this.targetAttribute + ']');
  },

  // carefully look into ::shadow with polyfill specific hack
  findInShadows: function(node, selector) {
    return node.querySelector(selector) || (hasShadowDOMPolyfill ? 
        Platform.queryAllShadows(node, selector) :
        node.querySelector('::shadow ' + selector));
  },

  findAllInShadows: function(node, selector) {
    if (hasShadowDOMPolyfill) {
      var nodes = node.querySelectorAll(selector).array();
      var shadowNodes = Platform.queryAllShadows(node, selector, true);
      return nodes.concat(shadowNodes);
    } else {
      return node.querySelectorAll(selector).array().concat(node.shadowRoot ? node.shadowRoot.querySelectorAll(selector).array() : []);
    }
  },

  go: function(scope, options) {
    this.player = document.timeline.play(this.animation);
    this.player.onfinish = this.complete.bind(this, scope);
  },

  setup: function(scope) {
    // if (!scope._pageTransitionStyles) {
    //   scope._pageTransitionStyles = {};
    // }

    // var name = this.calcStyleName();
    
    // if (!scope._pageTransitionStyles[name]) {
    //   this.installStyleInScope(scope, name);
    //   scope._pageTransitionStyles[name] = true;
    // }
  },

  calcStyleName: function() {
    return this.id || this.localName;
  },

  installStyleInScope: function(scope, id) {
    if (!scope.shadowRoot) {
      scope.createShadowRoot().innerHTML = '<content></content>';
    }
    var root = scope.shadowRoot;
    var scopeStyle = document.createElement('core-style');
    root.insertBefore(scopeStyle, root.firstChild);
    scopeStyle.applyRef(id);
  },

  // ensureComplete: function(scope) {
  //   if (this.completed) {
  //     return;
  //   }
  //   this.player.finish();
  //   this.complete(scope);
  // },

  complete: function(scope) {
    this.animation = null;
    this.player = null;
    this.fire('core-transitionend', this, scope);
  }

});

})();

</script>
</polymer-element>
